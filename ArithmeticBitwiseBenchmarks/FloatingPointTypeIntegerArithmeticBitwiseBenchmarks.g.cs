// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using System.Text;
using System.Threading.Tasks;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Jobs;

namespace ArithmeticBitwiseBenchmarks
{
    public partial class FloatingPointTypeIntegerArithmeticBitwiseBenchmarks
    {
        #region Categories
        private const string CategoryTypeSingle = "Single";
        private const string CategoryTypeDouble = "Double";
        private const string CategoryOperatorAddition = "Addition";
        private const string CategoryOperatorBitwiseAnd = "BitwiseAnd";
        private const string CategoryOperatorBitwiseOr = "BitwiseOr";
        private const string CategoryOperatorExclusiveOr = "ExclusiveOr";
        private const string CategoryOperatorSubtraction = "Subtraction";
        private const string CategoryOperatorOnesComplement = "OnesComplement";
        private const string CategoryOperatorUnaryNegation = "UnaryNegation";
        private const string CategoryOperatorUnsignedRightShift = "UnsignedRightShift";
        private const string CategoryOperatorRightShift = "RightShift";
        private const string CategoryOperatorLeftShift = "LeftShift";
        private const string CategoryOperatorDecrement = "Decrement";
        private const string CategoryOperatorIncrement = "Increment";
        #endregion Categories

        #region Single

        #region Commutative Binary Integer Operators with Single

        #region Addition

        #region Single With Single
        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleAdditionBitConverter(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(left) + BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleAdditionVector128(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt32() + Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Single

        #region Single With Constant Int32
        
        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32AdditionBitConverter(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) + 0x3f80_0000);
            }
            return acc;
        }

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32AdditionVector128(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() + Vector128.CreateScalarUnsafe(0x3f80_0000)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Constant Int32
        
        #region Single With Variable Int32 in GP register
        
        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32AdditionBitConverter(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) + right);
            }
            return acc;
        }

        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32AdditionVector128(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() + Vector128.CreateScalarUnsafe(right)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Variable Int32 in GP register

        #endregion Addition

        #region BitwiseAnd

        #region Single With Single
        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleBitwiseAndBitConverter(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(left) & BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleBitwiseAndVector128(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt32() & Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Single

        #region Single With Constant Int32
        
        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32BitwiseAndBitConverter(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) & 0x3f80_0000);
            }
            return acc;
        }

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32BitwiseAndVector128(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() & Vector128.CreateScalarUnsafe(0x3f80_0000)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Constant Int32
        
        #region Single With Variable Int32 in GP register
        
        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32BitwiseAndBitConverter(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) & right);
            }
            return acc;
        }

        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32BitwiseAndVector128(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() & Vector128.CreateScalarUnsafe(right)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Variable Int32 in GP register

        #endregion BitwiseAnd

        #region BitwiseOr

        #region Single With Single
        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleBitwiseOrBitConverter(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(left) | BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleBitwiseOrVector128(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt32() | Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Single

        #region Single With Constant Int32
        
        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32BitwiseOrBitConverter(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) | 0x3f80_0000);
            }
            return acc;
        }

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32BitwiseOrVector128(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() | Vector128.CreateScalarUnsafe(0x3f80_0000)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Constant Int32
        
        #region Single With Variable Int32 in GP register
        
        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32BitwiseOrBitConverter(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) | right);
            }
            return acc;
        }

        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32BitwiseOrVector128(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() | Vector128.CreateScalarUnsafe(right)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Variable Int32 in GP register

        #endregion BitwiseOr

        #region ExclusiveOr

        #region Single With Single
        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleExclusiveOrBitConverter(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(left) ^ BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleExclusiveOrVector128(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt32() ^ Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Single

        #region Single With Constant Int32
        
        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32ExclusiveOrBitConverter(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) ^ 0x3f80_0000);
            }
            return acc;
        }

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32ExclusiveOrVector128(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() ^ Vector128.CreateScalarUnsafe(0x3f80_0000)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Constant Int32
        
        #region Single With Variable Int32 in GP register
        
        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32ExclusiveOrBitConverter(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) ^ right);
            }
            return acc;
        }

        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32ExclusiveOrVector128(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() ^ Vector128.CreateScalarUnsafe(right)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Variable Int32 in GP register

        #endregion ExclusiveOr

        #endregion Commutative Binary Integer Operators with Single

        #region Non-Commutative Binary Integer Operators with Single

        #region Subtraction

        #region Single With Single
        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleSubtractionBitConverter(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(left) - BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0f, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleSingleSubtractionVector128(float left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt32() - Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Single

        #region Single With Constant Int32
        
        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32SubtractionBitConverter(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) - 0x3f80_0000);
            }
            return acc;
        }

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleConstInt32SubtractionVector128(float left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() - Vector128.CreateScalarUnsafe(0x3f80_0000)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Constant Int32
        
        #region Single With Variable Int32 in GP register
        
        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32SubtractionBitConverter(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(BitConverter.SingleToInt32Bits(acc) - right);
            }
            return acc;
        }

        [Arguments(3.0f, 0x3f80_0000)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleVariableInt32SubtractionVector128(float left, int right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt32() - Vector128.CreateScalarUnsafe(right)).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Single With Variable Int32 in GP register

        
        #region Constant Int32 With Single
        [Arguments(1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryConstIntWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float ConstInt32SingleSubtractionBitConverter(float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(0x3f80_0000 - BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryConstIntWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float ConstInt32SingleSubtractionVector128(float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(0x3f80_0000) - Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Constant Int32 With Single

        #region Variable Int32 in GP register With Single
        [Arguments(0x3f80_0000, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryGPIntWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float VariableInt32SingleSubtractionBitConverter(int left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(left - BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(0x3f80_0000, 1.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryBinary, CategoryOperatorSubtraction, CategoryGPIntWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float VariableInt32SingleSubtractionVector128(int left, float right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left) - Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }
        
        #endregion Variable Int32 in GP register With Single

        #endregion Subtraction

        #endregion Non-Commutative Binary Integer Operators with Single

        #region Unary Integer Operators with Single

        #region OnesComplement

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryUnary, CategoryOperatorOnesComplement, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleOnesComplementBitConverter(float value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(~BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryUnary, CategoryOperatorOnesComplement, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleOnesComplementVector128(float value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (~Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }

        #endregion OnesComplement

        #region UnaryNegation

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryUnary, CategoryOperatorUnaryNegation, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleUnaryNegationBitConverter(float value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int32BitsToSingle(-BitConverter.SingleToInt32Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0f)]
        [BenchmarkCategory(CategoryTypeSingle, CategoryUnary, CategoryOperatorUnaryNegation, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public float SingleUnaryNegationVector128(float value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (-Vector128.CreateScalarUnsafe(acc).AsInt32()).AsSingle().GetElement(0);
            }
            return acc;
        }

        #endregion UnaryNegation

        #endregion Unary Integer Operators with Single

        #endregion Single

        #region Double

        #region Commutative Binary Integer Operators with Double

        #region Addition

        #region Double With Double
        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleAdditionBitConverter(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(left) + BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleAdditionVector128(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt64() + Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Double

        #region Double With Constant Int64
        
        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64AdditionBitConverter(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) + 0x3FF0_0000_0000_0000L);
            }
            return acc;
        }

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64AdditionVector128(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() + Vector128.CreateScalarUnsafe(0x3FF0_0000_0000_0000L)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Constant Int64
        
        #region Double With Variable Int64 in GP register
        
        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64AdditionBitConverter(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) + right);
            }
            return acc;
        }

        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorAddition, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64AdditionVector128(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() + Vector128.CreateScalarUnsafe(right)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Variable Int64 in GP register

        #endregion Addition

        #region BitwiseAnd

        #region Double With Double
        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleBitwiseAndBitConverter(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(left) & BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleBitwiseAndVector128(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt64() & Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Double

        #region Double With Constant Int64
        
        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64BitwiseAndBitConverter(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) & 0x3FF0_0000_0000_0000L);
            }
            return acc;
        }

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64BitwiseAndVector128(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() & Vector128.CreateScalarUnsafe(0x3FF0_0000_0000_0000L)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Constant Int64
        
        #region Double With Variable Int64 in GP register
        
        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64BitwiseAndBitConverter(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) & right);
            }
            return acc;
        }

        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseAnd, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64BitwiseAndVector128(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() & Vector128.CreateScalarUnsafe(right)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Variable Int64 in GP register

        #endregion BitwiseAnd

        #region BitwiseOr

        #region Double With Double
        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleBitwiseOrBitConverter(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(left) | BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleBitwiseOrVector128(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt64() | Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Double

        #region Double With Constant Int64
        
        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64BitwiseOrBitConverter(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) | 0x3FF0_0000_0000_0000L);
            }
            return acc;
        }

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64BitwiseOrVector128(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() | Vector128.CreateScalarUnsafe(0x3FF0_0000_0000_0000L)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Constant Int64
        
        #region Double With Variable Int64 in GP register
        
        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64BitwiseOrBitConverter(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) | right);
            }
            return acc;
        }

        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorBitwiseOr, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64BitwiseOrVector128(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() | Vector128.CreateScalarUnsafe(right)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Variable Int64 in GP register

        #endregion BitwiseOr

        #region ExclusiveOr

        #region Double With Double
        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleExclusiveOrBitConverter(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(left) ^ BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleExclusiveOrVector128(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt64() ^ Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Double

        #region Double With Constant Int64
        
        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64ExclusiveOrBitConverter(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) ^ 0x3FF0_0000_0000_0000L);
            }
            return acc;
        }

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64ExclusiveOrVector128(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() ^ Vector128.CreateScalarUnsafe(0x3FF0_0000_0000_0000L)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Constant Int64
        
        #region Double With Variable Int64 in GP register
        
        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64ExclusiveOrBitConverter(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) ^ right);
            }
            return acc;
        }

        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorExclusiveOr, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64ExclusiveOrVector128(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() ^ Vector128.CreateScalarUnsafe(right)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Variable Int64 in GP register

        #endregion ExclusiveOr

        #endregion Commutative Binary Integer Operators with Double

        #region Non-Commutative Binary Integer Operators with Double

        #region Subtraction

        #region Double With Double
        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleSubtractionBitConverter(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(left) - BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleDoubleSubtractionVector128(double left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).AsInt64() - Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Double

        #region Double With Constant Int64
        
        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64SubtractionBitConverter(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) - 0x3FF0_0000_0000_0000L);
            }
            return acc;
        }

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleConstInt64SubtractionVector128(double left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() - Vector128.CreateScalarUnsafe(0x3FF0_0000_0000_0000L)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Constant Int64
        
        #region Double With Variable Int64 in GP register
        
        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64SubtractionBitConverter(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(acc) - right);
            }
            return acc;
        }

        [Arguments(3.0, 0x3FF0_0000_0000_0000L)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleVariableInt64SubtractionVector128(double left, long right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).AsInt64() - Vector128.CreateScalarUnsafe(right)).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Double With Variable Int64 in GP register

        
        #region Constant Int64 With Double
        [Arguments(1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryConstIntWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double ConstInt64DoubleSubtractionBitConverter(double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(0x3FF0_0000_0000_0000L - BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryConstIntWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double ConstInt64DoubleSubtractionVector128(double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(0x3FF0_0000_0000_0000L) - Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Constant Int64 With Double

        #region Variable Int64 in GP register With Double
        [Arguments(0x3FF0_0000_0000_0000L, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryGPIntWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double VariableInt64DoubleSubtractionBitConverter(long left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(left - BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(0x3FF0_0000_0000_0000L, 1.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryBinary, CategoryOperatorSubtraction, CategoryGPIntWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double VariableInt64DoubleSubtractionVector128(long left, double right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left) - Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }
        
        #endregion Variable Int64 in GP register With Double

        #endregion Subtraction

        #endregion Non-Commutative Binary Integer Operators with Double

        #region Unary Integer Operators with Double

        #region OnesComplement

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryUnary, CategoryOperatorOnesComplement, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleOnesComplementBitConverter(double value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(~BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryUnary, CategoryOperatorOnesComplement, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleOnesComplementVector128(double value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (~Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }

        #endregion OnesComplement

        #region UnaryNegation

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryUnary, CategoryOperatorUnaryNegation, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleUnaryNegationBitConverter(double value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.Int64BitsToDouble(-BitConverter.DoubleToInt64Bits(acc));
            }
            return acc;
        }

        [Arguments(3.0)]
        [BenchmarkCategory(CategoryTypeDouble, CategoryUnary, CategoryOperatorUnaryNegation, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public double DoubleUnaryNegationVector128(double value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (-Vector128.CreateScalarUnsafe(acc).AsInt64()).AsDouble().GetElement(0);
            }
            return acc;
        }

        #endregion UnaryNegation

        #endregion Unary Integer Operators with Double

        #endregion Double

    }
}
