<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#    var types = new (string langName, string fxName, string fxInt, string fxUInt, string langInt, string langUInt, string left, string right, string thirdInt)[]
                        {("float", "Single", "Int32", "UInt32", "int", "uint", "3.0f", "1.0f", "0x3f80_0000"),
                        ("double", "Double", "Int64", "UInt64", "long", "ulong", "3.0", "1.0", "0x3FF0_0000_0000_0000L")};#>
<#    var binaryCommutativeOperatorsVector128 = new (string name, string symbol)[]{("Addition","+"), ("BitwiseAnd","&"), ("BitwiseOr","|"), ("ExclusiveOr","^")};#>
<#    var binaryOperatorsVector128 = new (string name, string symbol)[]{("Subtraction","-")};#>
<#    var unaryOperatorsVector128 = new (string name, string symbol)[]{("OnesComplement", "~"), ("UnaryNegation", "-")};#>
<#    var binaryOperatorsSpecial = new (string name, string symbol)[]{("Multiply","*"), ("AndNot","&~"), ("UnsignedRightShift",">>>"), ("RightShift",">>"), ("LeftShift","<<")};#>
<#    var unaryOperatorsSpecial = new (string name, string symbol)[]{("Decrement", "--"), ("Increment", "++")};#>
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using System.Text;
using System.Threading.Tasks;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Jobs;
using static ArithmeticBitwiseBenchmarks.BenchmarkCategories;

namespace ArithmeticBitwiseBenchmarks
{
    public static partial class BenchmarkCategories
    {
        #region Categories
<#
    foreach(var type in types){#>
        public const string CategoryType<#=type.fxName#> = "<#=type.fxName#>";
<#
        }#>
<#
    foreach(var op in binaryCommutativeOperatorsVector128.Union(binaryOperatorsVector128).Union(unaryOperatorsVector128).Union(binaryOperatorsSpecial).Union(unaryOperatorsSpecial)){#>
        public const string CategoryOperator<#=op.name#> = "<#=op.name#>";  //<#=op.symbol#>
<#
        }#>
        #endregion Categories
    }
    public partial class FloatingPointTypeIntegerArithmeticBitwiseBenchmarks
    {
<#
    foreach(var type in types){#>
        #region <#=type.fxName#>

        #region Commutative Binary Integer Operators with <#=type.fxName#>

<#
        foreach(var op in binaryCommutativeOperatorsVector128){#>
        #region <#=op.name#>

<#      WriteFunctionsForBinaryCommutativeOperators(type, op);#>
        #endregion <#=op.name#>

<#
        }#>
        #endregion Commutative Binary Integer Operators with <#=type.fxName#>

        #region Non-Commutative Binary Integer Operators with <#=type.fxName#>

<#
        foreach(var op in binaryOperatorsVector128){#>
        #region <#=op.name#>

<#      WriteFunctionsForBinaryCommutativeOperators(type, op);#>
        
        #region Constant <#=type.fxInt#> With <#=type.fxName#>
        [Arguments(<#=type.right#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryConstIntWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> Const<#=type.fxInt#><#=type.fxName#><#=op.name#>BitConverter(<#=type.langName#> right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.<#=type.fxInt#>BitsTo<#=type.fxName#>(<#=type.thirdInt#> <#=op.symbol#> BitConverter.<#=type.fxName#>To<#=type.fxInt#>Bits(acc));
            }
            return acc;
        }

        [Arguments(<#=type.right#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryConstIntWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> Const<#=type.fxInt#><#=type.fxName#><#=op.name#>Vector128(<#=type.langName#> right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(<#=type.thirdInt#>) <#=op.symbol#> Vector128.CreateScalarUnsafe(acc).As<#=type.fxInt#>()).As<#=type.fxName#>().GetElement(0);
            }
            return acc;
        }
        
        #endregion Constant <#=type.fxInt#> With <#=type.fxName#>

        #region Variable <#=type.fxInt#> in GP register With <#=type.fxName#>
        [Arguments(<#=type.thirdInt#>, <#=type.right#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryGPIntWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> Variable<#=type.fxInt#><#=type.fxName#><#=op.name#>BitConverter(<#=type.langInt#> left, <#=type.langName#> right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.<#=type.fxInt#>BitsTo<#=type.fxName#>(left <#=op.symbol#> BitConverter.<#=type.fxName#>To<#=type.fxInt#>Bits(acc));
            }
            return acc;
        }

        [Arguments(<#=type.thirdInt#>, <#=type.right#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryGPIntWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> Variable<#=type.fxInt#><#=type.fxName#><#=op.name#>Vector128(<#=type.langInt#> left, <#=type.langName#> right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left) <#=op.symbol#> Vector128.CreateScalarUnsafe(acc).As<#=type.fxInt#>()).As<#=type.fxName#>().GetElement(0);
            }
            return acc;
        }
        
        #endregion Variable <#=type.fxInt#> in GP register With <#=type.fxName#>

        #endregion <#=op.name#>

<#
        }#>
        #endregion Non-Commutative Binary Integer Operators with <#=type.fxName#>

        #region Unary Integer Operators with <#=type.fxName#>

<#
        foreach(var op in unaryOperatorsVector128){#>
        #region <#=op.name#>

        [Arguments(<#=type.left#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryUnary, CategoryOperator<#=op.name#>, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> <#=type.fxName#><#=op.name#>BitConverter(<#=type.langName#> value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.<#=type.fxInt#>BitsTo<#=type.fxName#>(<#=op.symbol#>BitConverter.<#=type.fxName#>To<#=type.fxInt#>Bits(acc));
            }
            return acc;
        }

        [Arguments(<#=type.left#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryUnary, CategoryOperator<#=op.name#>, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> <#=type.fxName#><#=op.name#>Vector128(<#=type.langName#> value)
        {
            var acc = value;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (<#=op.symbol#>Vector128.CreateScalarUnsafe(acc).As<#=type.fxInt#>()).As<#=type.fxName#>().GetElement(0);
            }
            return acc;
        }

        #endregion <#=op.name#>

<#
        }#>
        #endregion Unary Integer Operators with <#=type.fxName#>

        #endregion <#=type.fxName#>

<#
    }#>
    }
}
<#+
    private void WriteFunctionsForBinaryCommutativeOperators(
        (string langName, string fxName, string fxInt, string fxUInt, string langInt, string langUInt, string left, string right, string thirdInt) type,
        (string name, string symbol) op)
    {
#>
        #region <#=type.fxName#> With <#=type.fxName#>
        [Arguments(<#=type.left#>, <#=type.right#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryFloatWithFloat, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> <#=type.fxName#><#=type.fxName#><#=op.name#>BitConverter(<#=type.langName#> left, <#=type.langName#> right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.<#=type.fxInt#>BitsTo<#=type.fxName#>(BitConverter.<#=type.fxName#>To<#=type.fxInt#>Bits(left) <#=op.symbol#> BitConverter.<#=type.fxName#>To<#=type.fxInt#>Bits(acc));
            }
            return acc;
        }

        [Arguments(<#=type.left#>, <#=type.right#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryFloatWithFloat, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> <#=type.fxName#><#=type.fxName#><#=op.name#>Vector128(<#=type.langName#> left, <#=type.langName#> right)
        {
            var acc = right;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(left).As<#=type.fxInt#>() <#=op.symbol#> Vector128.CreateScalarUnsafe(acc).As<#=type.fxInt#>()).As<#=type.fxName#>().GetElement(0);
            }
            return acc;
        }
        
        #endregion <#=type.fxName#> With <#=type.fxName#>

        #region <#=type.fxName#> With Constant <#=type.fxInt#>
        
        [Arguments(<#=type.left#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryFloatWithConstInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> <#=type.fxName#>Const<#=type.fxInt#><#=op.name#>BitConverter(<#=type.langName#> left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.<#=type.fxInt#>BitsTo<#=type.fxName#>(BitConverter.<#=type.fxName#>To<#=type.fxInt#>Bits(acc) <#=op.symbol#> <#=type.thirdInt#>);
            }
            return acc;
        }

        [Arguments(<#=type.left#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryFloatWithConstInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> <#=type.fxName#>Const<#=type.fxInt#><#=op.name#>Vector128(<#=type.langName#> left)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).As<#=type.fxInt#>() <#=op.symbol#> Vector128.CreateScalarUnsafe(<#=type.thirdInt#>)).As<#=type.fxName#>().GetElement(0);
            }
            return acc;
        }
        
        #endregion <#=type.fxName#> With Constant <#=type.fxInt#>
        
        #region <#=type.fxName#> With Variable <#=type.fxInt#> in GP register
        
        [Arguments(<#=type.left#>, <#=type.thirdInt#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryFloatWithGPInt, CategoryBitConverter)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> <#=type.fxName#>Variable<#=type.fxInt#><#=op.name#>BitConverter(<#=type.langName#> left, <#=type.langInt#> right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = BitConverter.<#=type.fxInt#>BitsTo<#=type.fxName#>(BitConverter.<#=type.fxName#>To<#=type.fxInt#>Bits(acc) <#=op.symbol#> right);
            }
            return acc;
        }

        [Arguments(<#=type.left#>, <#=type.thirdInt#>)]
        [BenchmarkCategory(CategoryType<#=type.fxName#>, CategoryBinary, CategoryOperator<#=op.name#>, CategoryFloatWithGPInt, CategoryVector128)]
        [Benchmark, MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public <#=type.langName#> <#=type.fxName#>Variable<#=type.fxInt#><#=op.name#>Vector128(<#=type.langName#> left, <#=type.langInt#> right)
        {
            var acc = left;
            for(int i = 0; i < LoopCount; i++)
            {
                acc = (Vector128.CreateScalarUnsafe(acc).As<#=type.fxInt#>() <#=op.symbol#> Vector128.CreateScalarUnsafe(right)).As<#=type.fxName#>().GetElement(0);
            }
            return acc;
        }
        
        #endregion <#=type.fxName#> With Variable <#=type.fxInt#> in GP register

<#+
    }
#>